def get_base_rules() -> str:
    return """BLOCKSWORLD ENVIRONMENT RULES

OVERVIEW:
The Blocksworld simulation is a classic AI planning domain where a single robot manipulates labeled blocks (A, B, C, etc.) in a simulated environment. The robot moves blocks between stacks to reach a desired configuration.

ELEMENTS IN THE ENVIRONMENT:
- ROBOT: One robot with a single gripper. It can hold at most one block at a time. The robot cannot pick up another block until the currently held block is placed.
- BLOCKS: Multiple blocks labeled with letters (A, B, C, etc.).
- STACKS: A fixed number of stacks exist:

ROBOT STATES:
- Idle: The robot is not holding any block.
- Holding: The robot is holding exactly one block.

BLOCK STATES:
- A block can be placed on a empty stack or on top of another block

STACK RULES:
- The stacks can be empty or already has blocks. 
- Only one block can be directly on top of another block.
- Blocks can be moved between stacks while respecting stack rules.

CONSTRAINTS:
- Only one action can be executed at a time.
- The robot can hold only one block at a time.
- Preconditions for each action must be satisfied before execution.
- Actions have deterministic effects.
- The environment is fully observable.
- Always check stack usage and robot status before acting.

AVAILABLE TOOLS: 
- pick_up("X"): picks up Block X from the stack if the stack has only Block X and no other Block
- unstack("X","Y"): unstacks the Block X from Block Y 
- put_down("X"): places Block X, which is held by the robot, onto an empty stack.
- stack("X","Y"): places the Block X above Block Y.
- get_status(): Returns the current status of the blocksworld system, including the position of all blocks, held blocks by the robot, and available empty positions in the stacks.

The AI agent can interact with the blocks world simulation to change the state of the blocks as per user request

PLANNING EXAMPLE IN BLOCKSWORLD SIMULATION :
User request:stack the blocks in the order  E–D–C–B–A from bottom to top.
Current State (status output):
{ "result": { "robot_status": { "holding": "None", "state": "idle" }, "stacks_status": [ { "Stack number": 1, "blocks_order_from_bottom ": ["A", "B", "E"] }, { "Stack number": 2, "blocks_order_from_bottom ": ["C", "D"] }, { "Stack number": 3, "blocks_order_from_bottom ": ["empty_stack"] } ] } }

PLAN GENERATED BY PLANNING AGENT:
[ "unstack('E','B')","put_down('E')","unstack('D','C')","stack('D','E')", "pick_up('C')", "stack('C','D')", "unstack('B','A')", "stack('B','C')", "unstack('B','A')", "stack('B','C')", "pick_up('A')", "stack('A','B')" ]

PLANNING CONSTRAINTS:
- Single-block holding: The robot can hold only one block at a time.
    - Do not execute `pick_up` or `unstack` immediately after another `pick_up` or `unstack`.
    - Ensure a `put_down` or `stack` occurs between these actions before picking up a new block.
- Sequential actions:
    - Do not execute `stack` immediately after another `stack`, or `put_down` immediately after another `put_down`, without first picking up or unstacking a new block.
- Block conditions:
    - Only `unstack` a block that is clear (no other block on top).
    - Only execute `stack` or `put_down` if the robot is currently holding a block.
- Redundancy avoidance:
    - Avoid repeating actions unnecessarily, such as `unstack('B','A')` immediately after moving B to another location.
- Stack management:
    - Consider the limited number of empty stack positions when planning moves.
    - Do not place a block on a full stack or violate stack capacity limits.
- Efficiency:
    - Plan actions to minimize unnecessary moves and keep the plan as short and efficient as possible.
- Preconditions:
    - Ensure all preconditions for an action are satisfied before including it in the plan."""